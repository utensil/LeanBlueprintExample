<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Parser.Term</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Parser.Term";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Lean/Parser/Attr.html">Lean.Parser.Attr</a></li><li><a href="../.././Lean/Parser/Level.html">Lean.Parser.Level</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Parser.Term" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody.formatter"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">formatter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.docComment"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">docComment</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.darrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">darrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.semicolonOrLinebreak"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">semicolonOrLinebreak</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.byTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.byTactic'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ident"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ident</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.num"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">num</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.scientific"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scientific</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.str"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">str</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.char"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">char</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.type"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">type</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sort"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sort</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">prop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sorry</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.cdot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">cdot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeAscription"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeAscription</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">tuple</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">paren</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.anonymousCtor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">anonymousCtor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.fromTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fromTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.showRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showRhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sufficesDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sufficesDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.suffices"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">suffices</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.show"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">show</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstFieldAbbrev"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldAbbrev</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.inaccessible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">inaccessible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.depArrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">depArrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forall"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forall</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAltExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchDiscr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchDiscr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.trueVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trueVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.falseVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">falseVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.generalizingParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">generalizingParam</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.motive"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">motive</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.match"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">match</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.nomatch"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nomatch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funStrictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funStrictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.basicFun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">basicFun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optExprPrecedence"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optExprPrecedence</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.withAnonymousAntiquot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withAnonymousAntiquot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.leading_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leading_parser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.trailing_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trailing_parser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.borrowed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">borrowed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.quotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">quotedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.doubleQuotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">doubleQuotedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdLhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letPatDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letPatDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letEqnsDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_fun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_delayed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_delayed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_tmp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_tmp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdLhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveEqnsDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.have"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">have</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.scoped"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scoped</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.local"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">local</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attrKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attrInstance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attributes"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attributes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letRecDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letRecDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letrec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.whereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">whereDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAltsWhereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltsWhereDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noindex"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noindex</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binrel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binrel_no_prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel_no_prop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binop_lazy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop_lazy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forInMacro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forInMacro'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.declName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">declName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.withDeclName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withDeclName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ensureTypeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureTypeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ensureExpectedType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureExpectedType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noImplicitLambda"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noImplicitLambda</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">clear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfTypeMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfTypeContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeContainsMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfContainsMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.defaultOrOfNonempty"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">defaultOrOfNonempty</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noErrorIfUnused"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noErrorIfUnused</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.namedArgument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedArgument</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ellipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ellipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.argument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">argument</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.app"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">app</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.proj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">proj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.completion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">completion</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.arrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">arrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.isIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">isIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitUniv"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitUniv</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.namedPattern"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.pipeProj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeProj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.pipeCompletion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeCompletion</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinderF"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinderF</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.panic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">panic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unreachable"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unreachable</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dbgTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.assert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">assert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroDollarArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroDollarArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroLastArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroLastArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.stateRefT"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">stateRefT</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dynamicQuot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dynamicQuot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dotIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dotIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.quotSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quotSeq</span></a></div></nav><main>
<div class="decl" id="Lean.Parser.Command.commentBody"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L13-L14">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Command.commentBody" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.commentBody.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L17-L17">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">Lean.PrettyPrinter.Parenthesizer</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Command.commentBody.parenthesizer" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.commentBody.formatter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L19-L19">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">formatter</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter">Lean.PrettyPrinter.Formatter</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Command.commentBody.formatter" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.docComment"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L26-L27">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">docComment</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment">docComment</a></code> parses a "documentation comment" like <code>/-- foo -/</code>. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.</p><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment">docComment</a></code> node contains a <code>/--</code> atom and then the remainder of the comment, <code>foo -/</code> in this
example. Use <code>TSyntax.getDocString</code> to extract the body text from a doc string syntax node.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Command.docComment" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.tacticParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L34-L35">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></span><span class="decl_args">
<span class="fn">(rbp : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Nat">Nat</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.tacticParser" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.convParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L37-L38">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></span><span class="decl_args">
<span class="fn">(rbp : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Nat">Nat</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.convParser" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepByIndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L52-L53">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>sepByIndentSemicolon(p)</code> parses a sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>manyIndent(p ";"?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.sepByIndentSemicolon" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepBy1IndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L65-L66">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>sepBy1IndentSemicolon(p)</code> parses a (nonempty) sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>many1Indent(p ";"?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.sepBy1IndentSemicolon" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq1Indented"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L72-L73">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticSeq1Indented" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqBracketed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L76-L77">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The syntax <code>{ tacs }</code> is an alternative syntax for <code>· tacs</code>.
It runs the tactics in sequence, and fails if the goal is not solved.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticSeqBracketed" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L81-L82">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.
Delimiter-free indentation is determined by the <em>first</em> tactic of the sequence.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticSeq" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqIndentGt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L87-L88">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Same as [<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq">tacticSeq</a></code>] but requires delimiter-free tactic sequence to have strict indentation.
The strict indentation requirement only apply to <em>nested</em> <code>by</code>s, as top-level <code>by</code>s do not have a
position set.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticSeqIndentGt" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.seq1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L91-L92">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.seq1" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.darrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L96-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.darrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">darrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.darrow" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.semicolonOrLinebreak"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L97-L97">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">semicolonOrLinebreak</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.semicolonOrLinebreak" class="instances-for-list"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Built-in-parsers">Built-in parsers <a class="hover-link" href="#Built-in-parsers">#</a></h1></div><div class="decl" id="Lean.Parser.Term.byTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L104-L105">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>by tac</code> constructs a term of the expected type by running the tactic(s) <code>tac</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.byTactic" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.byTactic'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L113-L114">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.byTactic'" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L117-L118">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.optSemicolon" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ident"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L121-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ident</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.ident" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.num"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L123-L124">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.num"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">num</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.num" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.scientific"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L125-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scientific"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scientific</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.scientific" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.str"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L127-L128">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.str"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">str</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.str" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.char"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L129-L130">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.char"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">char</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.char" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.type"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L132-L133">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.type"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">type</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A type universe. <code>Type ≡ Type 0</code>, <code>Type u ≡ Sort (u + 1)</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.type" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sort"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L135-L136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sort"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sort</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A specific universe in Lean's infinite hierarchy of universes.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.sort" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.prop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L138-L139">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">prop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The universe of propositions. <code>Prop ≡ Sort 0</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.prop" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.hole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L141-L142">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A placeholder term, to be synthesized by unification.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.hole" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.syntheticHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L145-L146">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Parses a "synthetic hole", that is, <code>?foo</code> or <code>?_</code>.
This syntax is used to construct named metavariables.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.syntheticHole" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L147-L147">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binderIdent" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L149-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sorry</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A temporary placeholder for a missing proof or value.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.sorry" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.cdot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L155-L156">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.cdot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">cdot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.
For example, <code>(· + ·)</code> is equivalent to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x y => x + y</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.cdot" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeAscription"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L163-L164">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeAscription"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeAscription</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Type ascription notation: <code>(0 : Int)</code> instructs Lean to process <code>0</code> as a value of type <code><a href="../.././Init/Data/Int/Basic.html#Int">Int</a></code>.
An empty type ascription <code>(e :)</code> elaborates <code>e</code> without the expected type.
This is occasionally useful when Lean's heuristics for filling arguments from the expected type
do not yield the right result.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.typeAscription" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.tuple"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L166-L167">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">tuple</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Tuple notation; <code>()</code> is short for <code><a href="../.././Init/Prelude.html#Unit.unit">Unit.unit</a></code>, <code>(a, b, c)</code> for <code><a href="../.././Init/Prelude.html#Prod.mk">Prod.mk</a> a (Prod.mk b c)</code>, etc.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.tuple" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L177-L178">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">paren</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Parentheses, used for grouping expressions (e.g., <code>a * (b + c)</code>).
Can also be used for creating simple functions when combined with <code>·</code>. Here are some examples:</p><ul>
<li><code>(· + 1)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x => x + 1</code></li>
<li><code>(· + ·)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x y => x + y</code></li>
<li><code>(f · a b)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x => f x a b</code></li>
<li><code>(h (· + 1) ·)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x => h (fun y => y + 1) x</code></li>
<li>also applies to other parentheses-like notations such as <code>(·, 1)</code></li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.paren" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.anonymousCtor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L186-L187">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">anonymousCtor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The <em>anonymous constructor</em> <code>⟨e, ...⟩</code> is equivalent to <code>c e ...</code> if the
expected type is an inductive type with a single constructor <code>c</code>.
If more terms are given than <code>c</code> has parameters, the remaining arguments
are turned into a new anonymous constructor application. For example,
<code>⟨a, b, c⟩ : α × (β × γ)</code> is equivalent to <code>⟨a, ⟨b, c⟩⟩</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.anonymousCtor" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L188-L189">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.optIdent" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.fromTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L190-L191">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fromTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fromTerm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.fromTerm" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.showRhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L192-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showRhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.showRhs" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sufficesDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L195-L196">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sufficesDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl">sufficesDecl</a></code> represents everything that comes after the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.suffices">suffices</a></code> keyword:
an optional <code>x :</code>, then a term <code>ty</code>, then <code>from val</code> or <code>by tac</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.sufficesDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.suffices"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L197-L198">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.suffices"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">suffices</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.suffices" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.show"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L199-L199">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.show"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">show</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.show" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstArrayRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L200-L201">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.structInstArrayRef" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstLVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L202-L204">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.structInstLVal" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstField"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L205-L206">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.structInstField" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstFieldAbbrev"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L207-L209">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldAbbrev</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.structInstFieldAbbrev" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optEllipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L210-L211">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.optEllipsis" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L221-L225">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Structure instance. <code>{ x := e, ... }</code> assigns <code>e</code> to field <code>x</code>, which may be
inherited. If <code>e</code> is itself a variable called <code>x</code>, it can be elided:
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> y => { x := 1, y }</code>.
A <em>structure update</em> of an existing value can be given via <code>with</code>:
<code>{ point with x := 1 }</code>.
The structure type can be specified if not inferable:
<code>{ x := 1, y := 2 : Point }</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.structInst" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeSpec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L226-L226">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.typeSpec" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L227-L227">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.optType" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L232-L233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>@x</code> disables automatic insertion of implicit parameters of the constant <code>x</code>.
<code>@e</code> for any term <code>e</code> also disables the insertion of implicit lambdas at this position.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.explicit" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.inaccessible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L238-L239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.inaccessible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">inaccessible</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>.(e)</code> marks an "inaccessible pattern", which does not influence evaluation of the pattern match, but may be necessary for type-checking.
In contrast to regular patterns, <code>e</code> may be an arbitrary term of the appropriate type.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.inaccessible" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L240-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binderType" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L242-L243">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binderTactic" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L244-L245">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binderDefault" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L248-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">Lean.PrettyPrinter.Parenthesizer</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binderDefault.parenthesizer" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L257-L258">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.explicitBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.implicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L263-L264">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Implicit binder. In regular applications without <code>@</code>, it is automatically inserted
and solved by unification whenever all explicit parameters before it are specified.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.implicitBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitLeftBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L265-L265">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.strictImplicitLeftBracket" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitRightBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L266-L266">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.strictImplicitRightBracket" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L272-L274">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Strict-implicit binder. In contrast to <code>{ ... }</code> regular implicit binders,
a strict-implicit binder is inserted automatically only when at least one subsequent
explicit parameter is specified.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.strictImplicitBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L279-L280">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Instance-implicit binder. In regular applications without <code>@</code>, it is automatically inserted
and solved by typeclass inference of the specified class.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.instBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L287-L290">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder">bracketedBinder</a></code> matches any kind of binder group that uses some kind of brackets:</p><ul>
<li>An explicit binder like <code>(x y : A)</code></li>
<li>An implicit binder like <code>{x y : A}</code></li>
<li>A strict implicit binder, <code>⦃y z : A⦄</code> or its ASCII alternative <code>{{y z : A}}</code></li>
<li>An instance binder <code>[A]</code> or <code>[x : A]</code> (multiple variables are not allowed here)</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.bracketedBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.depArrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L307-L308">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.depArrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">depArrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.depArrow" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forall"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L311-L314">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forall"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forall</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.forall" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L316-L321">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a> <span class="fn">Lean.Parser.termParser</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.matchAlt" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAltExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L325-L325">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Useful for syntax quotations. Note that generic patterns such as <code>`(matchAltExpr| | ... => $rhs)</code> should also
work with other <code>rhsParser</code>s (of arity 1).</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.matchAltExpr" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L327-L328">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> (<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAltExpr</span></span>) (<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAlt</span></span>)</span></div></div></div></div><div class="decl" id="Lean.Parser.Term.matchAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L330-L331">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlts</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a> <span class="fn">Lean.Parser.termParser</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.matchAlts" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchDiscr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L335-L336">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchDiscr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr">matchDiscr</a></code> matches a "match discriminant", either <code>h : tm</code> or <code>tm</code>, used in <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> as
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> h1 : e1, e2, h3 : e3 with ...</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.matchDiscr" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.trueVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L338-L338">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.trueVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trueVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.trueVal" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.falseVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L339-L339">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.falseVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">falseVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.falseVal" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.generalizingParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L340-L342">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">generalizingParam</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.generalizingParam" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.motive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L344-L346">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.motive"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">motive</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.motive" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.match"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L378-L380">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">match</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Pattern matching. <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> e, ... with | p, ... => f | ...</code> matches each given
term <code>e</code> against each pattern <code>p</code> of a match alternative. When all patterns
of an alternative match, the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> term evaluates to the value of the
corresponding right-hand side <code>f</code> with the pattern variables bound to the
respective matched values.
When not constructing a proof, <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> does not automatically substitute variables
matched on in dependent variables' types. Use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> (generalizing := true) ...</code> to
enforce this.</p><p>Syntax quotations can also be used in a pattern match.
This matches a <code>Syntax</code> value against quotations, pattern variables, or <code>_</code>.</p><p>Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.</p><p><code>Syntax.atom</code>s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in</p><pre><code class="language-lean">syntax "c" ("foo" <|> "bar") ...
</code></pre><p><code>foo</code> and <code>bar</code> are indistinguishable during matching, but in</p><pre><code class="language-lean">syntax foo := "foo"
syntax "c" (foo <|> "bar") ...
</code></pre><p>they are not.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.match" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.nomatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L386-L386">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nomatch"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nomatch</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Empty match/ex falso. <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nomatch">nomatch</a> e</code> is of arbitrary type <code>α : Sort u</code> if
Lean can show that an empty set of patterns is exhaustive given <code>e</code>'s type,
e.g. because it has no constructors.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.nomatch" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L388-L389">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funImplicitBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.funImplicitBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funStrictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L390-L394">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funStrictImplicitBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.funStrictImplicitBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L395-L397">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.funBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.basicFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L400-L401">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.basicFun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">basicFun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.basicFun" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.fun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L402-L403">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.fun" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optExprPrecedence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L405-L405">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optExprPrecedence</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.optExprPrecedence" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.withAnonymousAntiquot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L406-L408">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withAnonymousAntiquot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.withAnonymousAntiquot" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.leading_parser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L409-L410">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.leading_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leading_parser</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.leading_parser" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.trailing_parser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L411-L412">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trailing_parser</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.trailing_parser" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.borrowed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L414-L415">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.borrowed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">borrowed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.borrowed" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.quotedName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L417-L417">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.quotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">quotedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A literal of type <code>Name</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.quotedName" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.doubleQuotedName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L424-L425">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">doubleQuotedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A resolved name literal. Evaluates to the full name of the given constant if
existent in the current context, or else fails.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.doubleQuotedName" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L427-L429">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letIdBinder" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdLhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L431-L434">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdLhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letIdLhs" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L435-L436">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letIdDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letPatDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L437-L438">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letPatDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letPatDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letEqnsDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L455-L456">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letEqnsDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letEqnsDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L461-L465">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letDecl">letDecl</a></code> matches the body of a let declaration <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> f x1 x2 := e</code>,
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> pat := e</code> (where <code>pat</code> is an arbitrary term) or <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> f | pat1 => e1 | pat2 => e2 ...</code>
(a pattern matching declaration), except for the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> keyword itself.
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> rec</code> declarations are not handled here.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L487-L488">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> is used to declare a local definition. Example:</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := 1
<a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> y := x + 1
x + y
</code></pre><p>Since functions are first class citizens in Lean, you can use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> to declare
local functions too.</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> double := <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x => 2*x
double (double 3)
</code></pre><p>For recursive definitions, you should use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> rec</code>.
You can also perform pattern matching using <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>. For example,
assume <code>p</code> has type <code><a href="../.././Init/Prelude.html#Nat">Nat</a> × <a href="../.././Init/Prelude.html#Nat">Nat</a></code>, then you can write</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> (x, y) := p
x + y
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.let" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_fun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L494-L495">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_fun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a> x := v; b</code> is syntax sugar for <code>(fun x => b) v</code>.
It is very similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := v; b</code>, but they are not equivalent.
In <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code>, the value <code>v</code> has been abstracted away and cannot be accessed in <code>b</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.let_fun" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_delayed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L499-L500">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_delayed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_delayed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_delayed">let_delayed</a> x := v; b</code> is similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := v; b</code>, but <code>b</code> is elaborated before <code>v</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.let_delayed" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_tmp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L505-L506">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_tmp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_tmp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>-declaration that is only included in the elaborated term if variable is still there.
It is often used when building macros.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.let_tmp" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveIdLhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L509-L509">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdLhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.haveIdLhs" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveIdDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L510-L511">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.haveIdDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveEqnsDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L512-L513">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveEqnsDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.haveEqnsDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L517-L518">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveDecl">haveDecl</a></code> matches the body of a have declaration: <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> := e</code>, <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> f x1 x2 := e</code>,
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> pat := e</code> (where <code>pat</code> is an arbitrary term) or <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> f | pat1 => e1 | pat2 => e2 ...</code>
(a pattern matching declaration), except for the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a></code> keyword itself.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.haveDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.have"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L519-L520">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">have</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.have" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.scoped"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L522-L522">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scoped"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scoped</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.scoped" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.local"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L523-L523">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.local"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">local</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.local" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attrKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L525-L525">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrKind">attrKind</a></code> matches <code>("scoped" <|> "local")?</code>, used before an attribute like <code>@[local simp]</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.attrKind" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attrInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L526-L526">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrInstance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.attrInstance" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attributes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L528-L529">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attributes"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attributes</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.attributes" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letRecDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L532-L533">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl">letRecDecl</a></code> matches the body of a let-rec declaration: a doc comment, attributes, and then
a let declaration without the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> keyword, such as <code>/-- foo -/ @[simp] bar := 1</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letRecDecl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letRecDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L535-L536">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls">letRecDecls</a></code> matches <code>letRecDecl,+</code>, a comma-separated list of let-rec declarations (see <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl">letRecDecl</a></code>).</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letRecDecls" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L538-L540">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letrec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letrec" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.whereDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L543-L544">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.whereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">whereDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.whereDecls" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAltsWhereDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L547-L548">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltsWhereDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.matchAltsWhereDecls" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noindex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L550-L551">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noindex"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noindex</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.noindex" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binrel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L553-L554">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binrel" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binrel_no_prop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L556-L557">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel_no_prop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel">binrel</a></code>, but coerce <code>Prop</code> arguments into <code><a href="../.././Init/Prelude.html#Bool">Bool</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binrel_no_prop" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L558-L559">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binop" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binop_lazy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L560-L561">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop_lazy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.binop_lazy" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L562-L563">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.unop" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forInMacro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L565-L566">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forInMacro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.forInMacro" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forInMacro'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L567-L568">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.forInMacro'" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.declName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L571-L571">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.declName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">declName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A macro which evaluates to the name of the currently elaborating declaration.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.declName" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.withDeclName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L579-L580">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.withDeclName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withDeclName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><ul>
<li><code>with_decl_name% <a href="../.././Init/Prelude.html#id">id</a> e</code> elaborates <code>e</code> in a context while changing the effective
declaration name to <code><a href="../.././Init/Prelude.html#id">id</a></code>.</li>
<li><code>with_decl_name% ?id e</code> does the same, but resolves <code><a href="../.././Init/Prelude.html#id">id</a></code> as a new definition name
(appending the current namespaces).</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.withDeclName" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L581-L582">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeOf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.typeOf" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ensureTypeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L583-L584">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureTypeOf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.ensureTypeOf" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ensureExpectedType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L585-L586">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureExpectedType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.ensureExpectedType" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noImplicitLambda"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L587-L588">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noImplicitLambda</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.noImplicitLambda" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.clear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L594-L595">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">clear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>clear% x; e</code> elaborates <code>x</code> after clearing the free variable <code>x</code> from the local context.
If <code>x</code> cannot be cleared (due to dependencies), it will keep <code>x</code> without failing.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.clear" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L597-L598">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.letMVar" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfTypeMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L599-L600">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.waitIfTypeMVar" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfTypeContainsMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L601-L602">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeContainsMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.waitIfTypeContainsMVar" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfContainsMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L603-L604">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfContainsMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.waitIfContainsMVar" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.defaultOrOfNonempty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L606-L607">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">defaultOrOfNonempty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.defaultOrOfNonempty" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noErrorIfUnused"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L613-L614">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noErrorIfUnused</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Helper parser for marking <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code>-alternatives that should not trigger errors if unused.
We use them to implement <code>macro_rules</code> and <code>elab_rules</code></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.noErrorIfUnused" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.namedArgument"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L616-L617">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.namedArgument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedArgument</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.namedArgument" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ellipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L618-L619">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ellipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ellipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.ellipsis" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.argument"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L620-L623">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.argument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">argument</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.argument" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.app"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L627-L627">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.app"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">app</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.app" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.proj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L641-L642">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.proj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">proj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p>The <em>extended field notation</em> <code>e.f</code> is roughly short for <code>T.f e</code> where <code>T</code> is the type of <code>e</code>.
More precisely,</p><ul>
<li>if <code>e</code> is of a function type, <code>e.f</code> is translated to <code>Function.f (p := e)</code>
where <code>p</code> is the first explicit parameter of function type</li>
<li>if <code>e</code> is of a named type <code>T ...</code> and there is a declaration <code>T.f</code> (possibly from <code>export</code>),
<code>e.f</code> is translated to <code>T.f (p := e)</code> where <code>p</code> is the first explicit parameter of type <code>T ...</code></li>
<li>otherwise, if <code>e</code> is of a structure type,
the above is repeated for every base type of the structure.</li>
</ul><p>The field index notation <code>e.i</code>, where <code>i</code> is a positive number,
is short for accessing the <code>i</code>-th field (1-indexed) of <code>e</code> if it is of a structure type.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.proj" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.completion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L643-L644">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.completion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">completion</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.completion" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.arrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L645-L646">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.arrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">arrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.arrow" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.isIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L648-L650">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.isIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">isIdent</span></a></span><span class="decl_args">
<span class="fn">(stx : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Bool">Bool</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.isIdent" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitUniv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L653-L656">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitUniv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>x.{u, ...}</code> explicitly specifies the universes <code>u, ...</code> of the constant <code>x</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.explicitUniv" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.namedPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L658-L661">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.namedPattern"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedPattern</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>x@e</code> matches the pattern <code>e</code> and binds its value to the identifier <code>x</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.namedPattern" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.pipeProj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L667-L668">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeProj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeProj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>e |>.x</code> is a shorthand for <code>(e).x</code>.
It is especially useful for avoiding parentheses with repeated applications.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.pipeProj" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.pipeCompletion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L669-L670">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeCompletion</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.pipeCompletion" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.subst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L680-L681">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">subst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>h ▸ e</code> is a macro built on top of <code><a href="../.././Init/Prelude.html#Eq.rec">Eq.rec</a></code> and <code><a href="../.././Init/Prelude.html#Eq.symm">Eq.symm</a></code> definitions.
Given <code>h : a = b</code> and <code>e : p a</code>, the term <code>h ▸ e</code> has type <code>p b</code>.
You can also view <code>h ▸ e</code> as a "type casting" operation
where you change the type of <code>e</code> by using <code>h</code>.
See the Chapter "Quantifiers and Equality" in the manual
"Theorem Proving in Lean" for additional information.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.subst" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinderF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L683-L683">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinderF</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.bracketedBinderF" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L684-L684">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> (<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinderF</span></span>) (<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinder</span></span>)</span></div></div></div></div><div class="decl" id="Lean.Parser.Term.panic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L694-L695">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.panic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">panic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>panic! msg</code> formally evaluates to <code>@Inhabited.default α</code> if the expected type
<code>α</code> implements <code><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a></code>.
At runtime, <code>msg</code> and the file position are printed to stderr unless the C
function <code>lean_set_panic_messages(false)</code> has been executed before. If the C
function <code>lean_set_exit_on_panic(true)</code> has been executed before, the process is
then aborted.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.panic" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unreachable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L697-L698">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unreachable"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unreachable</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A shorthand for <code>panic! "unreachable code has been reached"</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.unreachable" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dbgTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L703-L705">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dbgTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>dbg_trace e; body</code> evaluates to <code>body</code> and prints <code>e</code> (which can be an
interpolated string literal) to stderr. It should only be used for debugging.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.dbgTrace" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.assert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L707-L708">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.assert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">assert</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>assert! <a href="../.././Init/Prelude.html#cond">cond</a></code> panics if <code><a href="../.././Init/Prelude.html#cond">cond</a></code> evaluates to <code>false</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.assert" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L711-L711">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.macroArg" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroDollarArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L712-L712">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroDollarArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.macroDollarArg" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroLastArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L713-L713">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroLastArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.macroLastArg" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.stateRefT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L716-L717">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.stateRefT"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">stateRefT</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.stateRefT" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dynamicQuot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L719-L720">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dynamicQuot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.dynamicQuot" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dotIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L722-L723">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dotIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dotIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Term.dotIdent" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L727-L728">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.quot" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.quotSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Term.lean#L729-L730">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quotSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.quotSeq" class="instances-for-list"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>