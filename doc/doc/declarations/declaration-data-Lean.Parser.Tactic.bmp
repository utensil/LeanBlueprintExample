{"name":"Lean.Parser.Tactic","instances":[],"imports":["Init","Lean.Parser.Term"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Tactic.lean#L92-L93","name":"Lean.Parser.Tactic.nativeDecide","line":92,"kind":"def","docLink":"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.nativeDecide","doc":"`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.nativeDecide\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">nativeDecide</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Tactic.lean#L76-L77","name":"Lean.Parser.Tactic.decide","line":76,"kind":"def","docLink":"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.decide","doc":"`decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Because this uses kernel\ncomputation to evaluate the term, it may not work in the presence of definitions\nby well founded recursion, since this requires reducing proofs.\n```\nexample : 2 + 2 â‰  5 := by decide\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.decide\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">decide</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Tactic.lean#L65-L66","name":"Lean.Parser.Tactic.introMatch","line":65,"kind":"def","docLink":"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.introMatch","doc":"The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.introMatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">introMatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Tactic.lean#L43-L46","name":"Lean.Parser.Tactic.match","line":43,"kind":"def","docLink":"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.match","doc":"`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.match\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">match</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Tactic.lean#L28-L28","name":"Lean.Parser.Tactic.matchAlts","line":28,"kind":"def","docLink":"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.matchAlts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.matchAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">matchAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Tactic.lean#L27-L27","name":"Lean.Parser.Tactic.matchRhs","line":27,"kind":"def","docLink":"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.matchRhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.matchRhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">matchRhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Tactic.lean#L25-L25","name":"Lean.Parser.Tactic.nestedTactic","line":25,"kind":"def","docLink":"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.nestedTactic","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.nestedTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">nestedTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Lean/Parser/Tactic.lean#L22-L23","name":"Lean.Parser.Tactic.unknown","line":22,"kind":"def","docLink":"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.unknown","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Tactic.html#Lean.Parser.Tactic.unknown\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unknown</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"}]}