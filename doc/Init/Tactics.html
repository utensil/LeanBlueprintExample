<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="stylesheet" href=".././src/pygments.css"></link><link rel="shortcut icon" href=".././favicon.ico"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Tactics</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Tactics";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Init</span>.<span class="name">Tactics</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Init</span>.<span class="name">Tactics</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/Notation.html">Init.Notation</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Tactics" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withAnnotateState"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withAnnotateState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.intro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.intros"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">intros</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rename"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rename</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.revert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">revert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">clear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.substVars"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">substVars</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.assumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">assumption</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.contradiction"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.apply"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">apply</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.exact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">exact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.refine"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refine</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.refine'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refine'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.constructor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">constructor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.case"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">case</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.case'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">case'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticNext_=>_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticNext_=>_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.allGoals"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">allGoals</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.anyGoals"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">anyGoals</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.focus"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">focus</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.skip"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">skip</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.done"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">done</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.traceState"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">traceState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.traceMessage"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">traceMessage</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.failIfSuccess"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">failIfSuccess</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">paren</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withReducible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withReducible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withReducibleAndInstances"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withReducibleAndInstances</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withUnfoldingAll"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withUnfoldingAll</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.first"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">first</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rotateLeft"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rotateLeft</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rotateRight"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rotateRight</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticTry_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticTry_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tactic_<;>_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tactic_<;>_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.refl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRfl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRfl'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRfl'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.acRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">acRfl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSorry</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticAdmit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticAdmit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticInfer_instance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticInfer_instance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.config"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">config</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.locationWildcard"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">locationWildcard</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.locationHyp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">locationHyp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.location"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">location</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.change"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">change</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.changeWith"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">changeWith</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwRule"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwRule</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwRuleSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwRuleSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rewriteSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rewriteSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.injection"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">injection</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.injections"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">injections</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.discharger"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">discharger</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpPre"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpPre</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpPost"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpPost</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpLemma"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpErase"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpErase</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpStar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpStar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpAll"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpAll</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dsimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.delta"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">delta</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.unfold"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">unfold</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRefine_lift_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRefine_lift_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticHave_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHave_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSuffices_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSuffices_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticLet_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLet_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticShow_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticShow_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">letrec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRefine_lift'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRefine_lift'_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticHave'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHave'_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticHave'_:=_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticHave'_:=_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticLet'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLet'_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAltLHS"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAltLHS</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.induction"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">induction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.generalizeArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">generalizeArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.generalize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">generalize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.casesTarget"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">casesTarget</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.cases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">cases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.renameI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">renameI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRepeat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRepeat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticTrivial"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticTrivial</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.split"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">split</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dbgTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticStop_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticStop_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.specialize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">specialize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticUnhygienic_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticUnhygienic_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.fail"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">fail</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.checkpoint"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">checkpoint</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.save"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">save</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sleep"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sleep</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticExists_,,»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticExists_,,»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.congr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">congr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.simp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">simp</span></a></div><div class="nav_link"><a class="break_within" href="#«term‹_›»"><span class="name">«term‹_›»</span></a></div><div class="nav_link"><a class="break_within" href="#tacticGet_elem_tactic_trivial"><span class="name">tacticGet_elem_tactic_trivial</span></a></div><div class="nav_link"><a class="break_within" href="#tacticGet_elem_tactic"><span class="name">tacticGet_elem_tactic</span></a></div><div class="nav_link"><a class="break_within" href="#«term__[_]»"><span class="name">«term__[_]»</span></a></div><div class="nav_link"><a class="break_within" href="#«term__[_]'_»"><span class="name">«term__[_]'_»</span></a></div></nav><main>
<div class="decl" id="Lean.Parser.Tactic.withAnnotateState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L11-L16">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withAnnotateState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_annotate_state stx t</code> annotates the lexical range of <code>stx : Syntax</code> with
the initial and final state of running tactic <code>t</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.withAnnotateState" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.intro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L18-L39">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.intro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">intro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must
be a <code>let</code> or function type.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code> by itself introduces one anonymous hypothesis, which can be accessed
by e.g. <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x y</code> introduces two hypotheses and names them. Individual hypotheses
can be anonymized via <code>_</code>, or matched against a pattern:
<pre><code class="language-lean">-- ... ⊢ α × β → ...
<a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> (a, b)
-- ..., a : α, b : β ⊢ ...
</code></pre>
</li>
<li>Alternatively, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code> can be combined with pattern matching much like <code>fun</code>:
<pre><code class="language-lean"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>
| n + 1, 0 => tac
| ...
</code></pre>
</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.intro" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.intros"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L41-L45">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.intros"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">intros</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a> x...</code> behaves like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x...</code>, but then keeps introducing (anonymous)
hypotheses until goal is not of a function type.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.intros" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rename"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L47-L51">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rename"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rename</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rename">rename</a> t => x</code> renames the most recent hypothesis whose type matches <code>t</code>
(which may contain placeholders) to <code>x</code>, or fails if no such hypothesis could be found.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.rename" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.revert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L53-L57">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.revert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">revert</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.revert">revert</a> x...</code> is the inverse of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x...</code>: it moves the given hypotheses
into the main goal's target type.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.revert" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.clear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L59-L63">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">clear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.clear">clear</a> x...</code> removes the given hypotheses, or fails if there are remaining
references to a hypothesis.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.clear" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.subst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L65-L70">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">subst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.subst">subst</a> x...</code> substitutes each <code>x</code> with <code>e</code> in the goal if there is a hypothesis
of type <code>x = e</code> or <code>e = x</code>.
If <code>x</code> is itself a hypothesis of type <code>y = e</code> or <code>e = y</code>, <code>y</code> is substituted instead.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.subst" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.substVars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L72-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.substVars"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">substVars</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.subst">subst</a></code> to all hypotheses of the form <code>h : x = t</code> or <code>h : t = x</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.substVars" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.assumption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L77-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">assumption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> tries to solve the main goal using a hypothesis of compatible type, or else fails.
Note also the <code>‹t›</code> term notation, which is a shorthand for <code>show t by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.assumption" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.contradiction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L83-L106">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">contradiction</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a></code> closes the main goal if its hypotheses are "trivially contradictory".</p><ul>
<li>Inductive type/family with no applicable constructors</li>
</ul><pre><code class="language-lean">example (h : False) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Injectivity of constructors</li>
</ul><pre><code class="language-lean">example (h : none = some true) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>  --
</code></pre><ul>
<li>Decidable false proposition</li>
</ul><pre><code class="language-lean">example (h : 2 + 2 = 3) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Contradictory hypotheses</li>
</ul><pre><code class="language-lean">example (h : p) (h' : ¬ p) : q := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Other simple contradictions such as</li>
</ul><pre><code class="language-lean">example (x : Nat) (h : x ≠ x) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.contradiction" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.apply"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L108-L117">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.apply"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">apply</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> e</code> tries to match the current goal against the conclusion of <code>e</code>'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.</p><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code> tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.apply" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.exact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L119-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.exact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">exact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> e</code> closes the main goal if its target type matches that of <code>e</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.exact" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.refine"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L124-L129">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.refine"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refine</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> e</code> behaves like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> e</code>, except that named (<code>?x</code>) or unnamed (<code>?_</code>)
holes in <code>e</code> that are not solved by unification with the main goal's target type
are converted into new goals, using the hole's name, if any, as the goal case name.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.refine" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.refine'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L131-L135">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refine'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a> e</code> behaves like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> e</code>, except that unsolved placeholders (<code>_</code>)
and implicit parameters are also converted into new goals.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.refine'" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.constructor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L137-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.constructor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">constructor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>If the main goal's target type is an inductive type, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.constructor">constructor</a></code> solves it with
the first matching constructor, or else fails.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.constructor" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.case"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L143-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.case"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">case</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag => tac</code> focuses on the goal with case name <code>tag</code> and solves it using <code>tac</code>,
or else fails.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag x₁ ... xₙ => tac</code> additionally renames the <code>n</code> most recent hypotheses
with inaccessible names to the given names.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag₁ | tag₂ => tac</code> is equivalent to <code>(case tag₁ => tac); (case tag₂ => tac)</code>.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.case" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.case'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L152-L158">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.case'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">case'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case'">case'</a></code> is similar to the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag => tac</code> tactic, but does not ensure the goal
has been solved after applying <code>tac</code>, nor admits the goal if <code>tac</code> failed.
Recall that <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a></code> closes the goal using <code>sorry</code> when <code>tac</code> fails, and
the tactic execution is not interrupted.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.case'" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticNext_=>_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L165-L165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticNext_=>_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticNext_=>_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>next => tac</code> focuses on the next goal and solves it using <code>tac</code>, or else fails.
<code>next x₁ ... xₙ => tac</code> additionally renames the <code>n</code> most recent hypotheses with
inaccessible names to the given names.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.«tacticNext_=>_»" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.allGoals"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L167-L168">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.allGoals"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">allGoals</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>all_goals tac</code> runs <code>tac</code> on each goal, concatenating the resulting goals, if any.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.allGoals" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.anyGoals"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L170-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.anyGoals"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">anyGoals</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>any_goals tac</code> applies the tactic <code>tac</code> to every goal, and succeeds if at
least one application succeeds.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.anyGoals" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.focus"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L176-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.focus"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">focus</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.focus">focus</a> tac</code> focuses on the main goal, suppressing all other goals, and runs <code>tac</code> on it.
Usually <code>· tac</code>, which enforces that the goal is closed by <code>tac</code>, should be preferred.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.focus" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.skip"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L182-L183">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.skip"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">skip</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">skip</a></code> does nothing.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.skip" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.done"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L185-L186">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.done"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">done</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.done">done</a></code> succeeds iff there are no remaining goals.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.done" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.traceState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L188-L189">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.traceState"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">traceState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>trace_state</code> displays the current state in the info view.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.traceState" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.traceMessage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L191-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.traceMessage"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">traceMessage</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>trace msg</code> displays <code>msg</code> in the info view.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.traceMessage" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.failIfSuccess"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L194-L195">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">failIfSuccess</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>fail_if_success t</code> fails if the tactic <code>t</code> succeeds.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.failIfSuccess" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L197-L202">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">paren</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>(tacs)</code> executes a list of tactics in sequence, without requiring that
the goal be closed at the end like <code>· tacs</code>. Like <code>by</code> itself, the tactics
can be either separated by newlines or <code>;</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.paren" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withReducible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L204-L208">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withReducible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withReducible</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_reducible tacs</code> excutes <code>tacs</code> using the reducible transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> are unfolded.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.withReducible" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withReducibleAndInstances"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L210-L214">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withReducibleAndInstances</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_reducible_and_instances tacs</code> excutes <code>tacs</code> using the <code>.instances</code> transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> or type class instances are unfolded.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.withReducibleAndInstances" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withUnfoldingAll"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L216-L220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withUnfoldingAll</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_unfolding_all tacs</code> excutes <code>tacs</code> using the <code>.all</code> transparency setting.
In this setting all definitions that are not opaque are unfolded.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.withUnfoldingAll" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.first"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L222-L223">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.first"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">first</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.first">first</a> | tac | ...</code> runs each <code>tac</code> until one succeeds, or else fails.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.first" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rotateLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L225-L230">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rotateLeft"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rotateLeft</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rotate_left n</code> rotates goals to the left by <code>n</code>. That is, <code>rotate_left 1</code>
takes the main goal and puts it to the back of the subgoal list.
If <code>n</code> is omitted, it defaults to <code>1</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.rotateLeft" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rotateRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L232-L236">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rotateRight"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rotateRight</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Rotate the goals to the right by <code>n</code>. That is, take the goal at the back
and push it to the front <code>n</code> times. If <code>n</code> is omitted, it defaults to <code>1</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.rotateRight" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticTry_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L239-L239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticTry_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticTry_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>try tac</code> runs <code>tac</code> and succeeds even if <code>tac</code> failed.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticTry_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tactic_<;>_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L245-L250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tactic_<;>_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tactic_<;>_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>tac <;> tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal,
concatenating all goals produced by <code>tac'</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.«tactic_<;>_»" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.refl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L252-L253">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.refl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>eq_refl</code> is equivalent to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code>, but has a few optimizations.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.refl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L260-L260">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRfl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#rfl">rfl</a></code> tries to close the current goal using reflexivity.
This is supposed to be an extensible tactic and users can add their own support
for new reflexive relations.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticRfl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRfl'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L266-L266">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRfl'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rfl'</code> is similar to <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, but disables smart unfolding and unfolds all kinds of definitions,
theorems included (relevant for declarations defined by well-founded recursion).</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticRfl'" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.acRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L268-L277">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.acRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">acRfl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>ac_rfl</code> proves equalities up to application of an associative and commutative operator.</p><pre><code>instance : IsAssociative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩
instance : IsCommutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.acRfl" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L286-L286">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSorry</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>sorry</code> tactic closes the goal using <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a></code>. This is intended for stubbing out incomplete
parts of a proof while still having a syntactically correct proof skeleton. Lean will give
a warning whenever a proof uses <code>sorry</code>, so you aren't likely to miss it, but
you can double check if a theorem depends on <code>sorry</code> by using
<code>#print axioms my_thm</code> and looking for <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a></code> in the axiom list.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticSorry" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticAdmit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L289-L289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticAdmit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>admit</code> is a shorthand for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> sorry</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticAdmit" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticInfer_instance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L295-L295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticInfer_instance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>infer_instance</code> is an abbreviation for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#inferInstance">inferInstance</a></code>.
It synthesizes a value of any target type by typeclass inference.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticInfer_instance" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.config"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L297-L298">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.config"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Optional configuration option for tactics</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.config" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.locationWildcard"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L300-L301">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.locationWildcard"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">locationWildcard</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>*</code> location refers to all hypotheses and the goal.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.locationWildcard" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.locationHyp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L303-L307">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.locationHyp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">locationHyp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A hypothesis location specification consists of 1 or more hypothesis references
and optionally <code>⊢</code> denoting the goal.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.locationHyp" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.location"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L309-L318">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.location"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">location</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:</p><ul>
<li>'empty' is not actually present in this syntax, but most tactics use
<code>(location)?</code> matchers. It means to target the goal only.</li>
<li><code>at h₁ ... hₙ</code>: target the hypotheses <code>h₁</code>, ..., <code>hₙ</code></li>
<li><code>at h₁ h₂ ⊢</code>: target the hypotheses <code>h₁</code> and <code>h₂</code>, and the goal</li>
<li><code>at *</code>: target all hypotheses and the goal</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.location" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.change"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L320-L326">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.change"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">change</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> tgt'</code> will change the goal from <code>tgt</code> to <code>tgt'</code>,
assuming these are definitionally equal.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> t' at h</code> will change hypothesis <code>h : t</code> to have type <code>t'</code>, assuming
assuming <code>t</code> and <code>t'</code> are definitionally equal.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.change" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.changeWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L328-L333">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.changeWith"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">changeWith</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> a with b</code> will change occurrences of <code>a</code> to <code>b</code> in the goal,
assuming <code>a</code> and <code>b</code> are are definitionally equal.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> a with b at h</code> similarly changes <code>a</code> to <code>b</code> in the type of hypothesis <code>h</code>.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.changeWith" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwRule"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L335-L340">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRule"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwRule</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>If <code>thm</code> is a theorem <code>a = b</code>, then as a rewrite rule,</p><ul>
<li><code>thm</code> means to replace <code>a</code> with <code>b</code>, and</li>
<li><code>← thm</code> means to replace <code>b</code> with <code>a</code>.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.rwRule" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwRuleSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L341-L342">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwRuleSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">rwRuleSeq</a></code> is a list of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRule">rwRule</a></code> in brackets.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.rwRuleSeq" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rewriteSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L344-L363">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rewriteSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rewrite [e]</code> applies identity <code>e</code> as a rewrite rule to the target of the main goal.
If <code>e</code> is preceded by left arrow (<code>←</code> or <code><-</code>), the rewrite is applied in the reverse direction.
If <code>e</code> is a defined constant, then the equational theorems associated with <code>e</code> are used.
This provides a convenient way to unfold <code>e</code>.</p><ul>
<li><code>rewrite [e₁, ..., eₙ]</code> applies the given rules sequentially.</li>
<li><code>rewrite [e] at l</code> rewrites <code>e</code> at location(s) <code>l</code>, where <code>l</code> is either <code>*</code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code>⊢</code> or <code>|-</code>
can also be used, to signify the target of the goal.</li>
</ul><p>Using <code>rw (config := {occs := .pos L}) [e]</code>,
where <code>L : <a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Nat">Nat</a></code>, you can control which "occurrences" are rewritten.
(This option applies to each rule, so usually this will only be used with a single rule.)
Occurrences count from <code>1</code>.
At the first occurrence, whether allowed or not,
arguments of the rewrite rule <code>e</code> may be instantiated,
restricting which later rewrites can be found.
<code>{occs := .neg L}</code> allows skipping specified occurrences.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.rewriteSeq" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L368-L373">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rw</code> is like <code>rewrite</code>, but also tries to close the goal by "cheap" (reducible) <code><a href=".././Init/Prelude.html#rfl">rfl</a></code> afterwards.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.rwSeq" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.injection"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L375-L388">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.injection"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">injection</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> tactic is based on the fact that constructors of inductive data
types are injections.
That means that if <code>c</code> is a constructor of an inductive datatype, and if <code>(c t₁)</code>
and <code>(c t₂)</code> are two terms that are equal then  <code>t₁</code> and <code>t₂</code> are equal too.
If <code>q</code> is a proof of a statement of conclusion <code>t₁ = t₂</code>, then injection applies
injectivity to derive the equality of all arguments of <code>t₁</code> and <code>t₂</code> placed in
the same positions. For example, from <code>(a::b) = (c::d)</code> we derive <code>a=c</code> and <code>b=d</code>.
To use this tactic <code>t₁</code> and <code>t₂</code> should be constructor applications of the same constructor.
Given <code>h : a::b = c::d</code>, the tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a> h</code> adds two new hypothesis with types
<code>a = c</code> and <code>b = d</code> to the main goal.
The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a> h with h₁ h₂</code> uses the names <code>h₁</code> and <code>h₂</code> to name the new hypotheses.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.injection" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.injections"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L390-L394">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.injections"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">injections</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injections">injections</a></code> applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> to all hypotheses recursively
(since <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> can produce new hypotheses). Useful for destructing nested
constructor equalities like <code>(a::b::c) = (d::e::f)</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.injections" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.discharger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L396-L400">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.discharger"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">discharger</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The discharger clause of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> and related tactics.
This is a tactic used to discharge the side conditions on conditional rewrite rules.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.discharger" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpPre"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L402-L403">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPre"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpPre</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Use this rewrite rule before entering the subterms</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.simpPre" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpPost"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L404-L405">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPost"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpPost</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Use this rewrite rule after entering the subterms</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.simpPost" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpLemma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L406-L412">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpLemma"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpLemma</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A simp lemma specification is:</p><ul>
<li>optional <code>↑</code> or <code>↓</code> to specify use before or after entering the subterm</li>
<li>optional <code>←</code> to use the lemma backward</li>
<li><code>thm</code> for the theorem to rewrite with</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.simpLemma" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpErase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L413-L414">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpErase"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpErase</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An erasure specification <code>-thm</code> says to remove <code>thm</code> from the simp set</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.simpErase" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpStar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L415-L416">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpStar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpStar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The simp lemma specification <code>*</code> means to rewrite with all hypotheses</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.simpStar" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L417-L438">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> simplifies the main goal target using lemmas tagged with the attribute <code>[simp]</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [h₁, h₂, ..., hₙ]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code> and the given <code>hᵢ</code>'s, where the <code>hᵢ</code>'s are expressions.
If an <code>hᵢ</code> is a defined constant <code>f</code>, then the equational lemmas associated with
<code>f</code> are used. This provides a convenient way to unfold <code>f</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*]</code> simplifies the main goal target using the lemmas tagged with the
attribute <code>[simp]</code> and all hypotheses.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [h₁, h₂, ..., hₙ]</code> is like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [h₁, h₂, ..., hₙ]</code> but does not use <code>[simp]</code> lemmas.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [-id₁, ..., -idₙ]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code>, but removes the ones named <code>idᵢ</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> at h₁ h₂ ... hₙ</code> simplifies the hypotheses <code>h₁ : T₁</code> ... <code>hₙ : Tₙ</code>. If
the target or another hypothesis depends on <code>hᵢ</code>, a new simplified hypothesis
<code>hᵢ</code> is introduced, but the old one remains in the local context.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> at *</code> simplifies all the hypotheses and the target.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*] at *</code> simplifies target and all (propositional) hypotheses using the
other hypotheses.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.simp" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpAll"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L439-L445">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpAll"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpAll</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp_all</code> is a stronger version of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*] at *</code> where the hypotheses and target
are simplified multiple times until no simplication is applicable.
Only non-dependent propositional hypotheses are considered.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.simpAll" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dsimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L447-L453">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code> tactic is the definitional simplifier. It is similar to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> but only
applies theorems that hold by reflexivity. Thus, the result is guaranteed to be
definitionally equal to the input.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.dsimp" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.delta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L455-L460">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.delta"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">delta</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.delta">delta</a> id1 id2 ...</code> delta-expands the definitions <code>id1</code>, <code>id2</code>, ....
This is a low-level tactic, it will expose how recursive definitions have been
compiled by Lean.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.delta" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.unfold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L462-L470">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">unfold</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> <a href=".././Init/Prelude.html#id">id</a></code> unfolds definition <code><a href=".././Init/Prelude.html#id">id</a></code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id1 id2 ...</code> is equivalent to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id1; <a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id2; ...</code>.</li>
</ul><p>For non-recursive definitions, this tactic is identical to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.delta">delta</a></code>.
For definitions by pattern matching, it uses "equation lemmas" which are
autogenerated for each match arm.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.unfold" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRefine_lift_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L476-L476">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRefine_lift_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Auxiliary macro for lifting have/suffices/let/...
It makes sure the "continuation" <code>?_</code> is the main goal after refining.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticRefine_lift_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticHave_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L488-L488">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticHave_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHave_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>have h : t := e</code> adds the hypothesis <code>h : t</code> to the current goal if <code>e</code> a term
of type <code>t</code>.</p><ul>
<li>If <code>t</code> is omitted, it will be inferred.</li>
<li>If <code>h</code> is omitted, the name <code>this</code> is used.</li>
<li>The variant <code>have pattern := e</code> is equivalent to <code>match e with | pattern => _</code>,
and it is convenient for types that have only one applicable constructor.
For example, given <code>h : p ∧ q ∧ r</code>, <code>have ⟨h₁, h₂, h₃⟩ := h</code> produces the
hypotheses <code>h₁ : p</code>, <code>h₂ : q</code>, and <code>h₃ : r</code>.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticHave_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSuffices_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L497-L497">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSuffices_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Given a main goal <code>ctx ⊢ t</code>, <code>suffices h : t' from e</code> replaces the main goal with <code>ctx ⊢ t'</code>,
<code>e</code> must have type <code>t</code> in the context <code>ctx, h : t'</code>.</p><p>The variant <code>suffices h : t' by tac</code> is a shorthand for <code>suffices h : t' from by tac</code>.
If <code>h :</code> is omitted, the name <code>this</code> is used.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticSuffices_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticLet_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L506-L506">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticLet_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLet_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>let h : t := e</code> adds the hypothesis <code>h : t := e</code> to the current goal if <code>e</code> a term of type <code>t</code>.
If <code>t</code> is omitted, it will be inferred.
The variant <code>let pattern := e</code> is equivalent to <code>match e with | pattern => _</code>,
and it is convenient for types that have only applicable constructor.
Example: given <code>h : p ∧ q ∧ r</code>, <code>let ⟨h₁, h₂, h₃⟩ := h</code> produces the hypotheses
<code>h₁ : p</code>, <code>h₂ : q</code>, and <code>h₃ : r</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticLet_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticShow_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L511-L511">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticShow_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticShow_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>show t</code> finds the first goal whose target unifies with <code>t</code>. It makes that the main goal,
performs the unification, and replaces the target with the unified version of <code>t</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticShow_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.letrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L512-L514">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">letrec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>let rec f : t := e</code> adds a recursive definition <code>f</code> to the current goal.
The syntax is the same as term-mode <code>let rec</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.letrec" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRefine_lift'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L519-L519">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRefine_lift'_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>refine_lift</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticRefine_lift'_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticHave'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L521-L521">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticHave'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHave'_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>have</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticHave'_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticHave'_:=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L523-L523">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticHave'_:=_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticHave'_:=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>have</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.«tacticHave'_:=_»" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticLet'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L525-L525">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticLet'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLet'_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>let</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticLet'_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAltLHS"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L527-L532">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAltLHS</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The left hand side of an induction arm, <code>| foo a b c</code> or <code>| @foo a b c</code>
where <code>foo</code> is a constructor of the inductive type and <code>a b c</code> are the arguments
to the contstructor.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.inductionAltLHS" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L533-L537">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAlt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>In induction alternative, which can have 1 or more cases on the left
and <code>_</code>, <code>?_</code>, or a tactic sequence after the <code>=></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.inductionAlt" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L538-L542">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>After <code>with</code>, there is an optional tactic that runs on all branches, and
then a list of alternatives.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.inductionAlts" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.induction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L544-L571">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.induction"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">induction</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> x</code> applies induction on <code>x</code> to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.</p><p>For example, given <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypotheses <code>h : P (Nat.succ a)</code> and <code>ih₁ : P a → Q a</code> and target <code>Q (Nat.succ a)</code>.
Here the names <code>a</code> and <code>ih₁</code> are chosen automatically and are not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e</code>, where <code>e</code> is an expression instead of a variable,
generalizes <code>e</code> in the goal, and then performs induction on the resulting variable.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e using r</code> allows the user to specify the principle of induction that should be used.
Here <code>r</code> should be a theorem whose result type must be of the form <code>C t</code>,
where <code>C</code> is a bound variable and <code>t</code> is a (possibly empty) sequence of bound variables</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e generalizing z₁ ... zₙ</code>, where <code>z₁ ... zₙ</code> are variables in the local context,
generalizes over <code>z₁ ... zₙ</code> before applying the induction but then introduces them in each goal.
In other words, the net effect is that each inductive hypothesis is generalized.</li>
<li>Given <code>x : <a href=".././Init/Prelude.html#Nat">Nat</a></code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> x with | zero => tac₁ | succ x' ih => tac₂</code>
uses tactic <code>tac₁</code> for the <code>zero</code> case, and <code>tac₂</code> for the <code>succ</code> case.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.induction" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.generalizeArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L573-L574">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.generalizeArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">generalizeArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a></code> argument, of the form <code>term = x</code> or <code>h : term = x</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.generalizeArg" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.generalize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L576-L583">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">generalize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> ([h :] e = x),+</code> replaces all occurrences <code>e</code>s in the main goal
with a fresh hypothesis <code>x</code>s. If <code>h</code> is given, <code>h : e = x</code> is introduced as well.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> e = x at h₁ ... hₙ</code> also generalizes occurrences of <code>e</code>
inside <code>h₁</code>, ..., <code>hₙ</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> e = x at *</code> will generalize occurrences of <code>e</code> everywhere.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.generalize" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.casesTarget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L585-L589">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.casesTarget"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">casesTarget</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a></code> argument, of the form <code>e</code> or <code>h : e</code> (where <code>h</code> asserts that
<code>e = cᵢ a b</code> for each constructor <code>cᵢ</code> of the inductive).</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.casesTarget" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.cases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L590-L613">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.cases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">cases</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> x</code> splits the main goal, producing one goal for each constructor of the
inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well.
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a></code> detects unreachable cases and closes them automatically.</p><p>For example, given <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypothesis <code>h : P (Nat.succ a)</code> and target <code>Q (Nat.succ a)</code>.
Here the name <code>a</code> is chosen automatically and is not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then cases on the resulting variable.</li>
<li>Given <code>as : <a href=".././Init/Prelude.html#List">List</a> α</code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> as with | nil => tac₁ | cons a as' => tac₂</code>,
uses tactic <code>tac₁</code> for the <code>nil</code> case, and <code>tac₂</code> for the <code>cons</code> case,
and <code>a</code> and <code>as'</code> are used as names for the new variables introduced.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> h : e</code>, where <code>e</code> is a variable or an expression,
performs cases on <code>e</code> as above, but also adds a hypothesis <code>h : e = ...</code> to each hypothesis,
where <code>...</code> is the constructor instance for that particular case.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.cases" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.renameI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L615-L616">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.renameI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">renameI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rename_i x_1 ... x_n</code> renames the last <code>n</code> inaccessible names using the given names.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.renameI" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRepeat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L618-L623">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRepeat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>repeat tac</code> repeatedly applies <code>tac</code> to the main goal until it fails.
That is, if <code>tac</code> produces multiple subgoals, only subgoals up to the first failure will be visited.
The <code>Std</code> library provides <code>repeat'</code> which repeats separately in each subgoal.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticRepeat_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticTrivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L627-L635">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticTrivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Core.html#trivial">trivial</a></code> tries different simple tactics (e.g., <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a></code>, ...)
to close the current goal.
You can use the command <code>macro_rules</code> to extend the set of tactics used. Example:</p><pre><code>macro_rules | `(tactic| trivial) => `(tactic| simp)
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticTrivial" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.split"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L637-L649">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.split"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">split</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> tactic is useful for breaking nested if-then-else and <code>match</code> expressions into separate cases.
For a <code>match</code> expression with <code>n</code> cases, the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> tactic generates at most <code>n</code> subgoals.</p><p>For example, given <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code>, and a target <code>if n = 0 then Q else R</code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> will generate
one goal with hypothesis <code>n = 0</code> and target <code>Q</code>, and a second goal with hypothesis
<code>¬n = 0</code> and target <code>R</code>.  Note that the introduced hypothesis is unnamed, and is commonly
renamed used the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a></code> or <code>next</code> tactics.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> will split the goal (target).</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a> at h</code> will split the hypothesis <code>h</code>.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.split" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dbgTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L651-L660">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dbgTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>dbg_trace "foo"</code> prints <code>foo</code> when elaborated.
Useful for debugging tactic control flow:</p><pre><code>example : <a href=".././Init/Prelude.html#False">False</a> ∨ <a href=".././Init/Prelude.html#True">True</a> := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.first">first</a>
  | <a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> Or.inl; trivial; dbg_trace "left"
  | <a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> Or.inr; trivial; dbg_trace "right"
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.dbgTrace" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticStop_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L668-L668">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticStop_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticStop_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>stop</code> is a helper tactic for "discarding" the rest of a proof:
it is defined as <code>repeat sorry</code>.
It is useful when working on the middle of a complex proofs,
and less messy than commenting the remainder of the proof.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticStop_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.specialize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L670-L678">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.specialize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">specialize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.specialize">specialize</a> h a₁ ... aₙ</code> works on local hypothesis <code>h</code>.
The premises of this hypothesis, either universal quantifications or
non-dependent implications, are instantiated by concrete terms coming
from arguments <code>a₁</code> ... <code>aₙ</code>.
The tactic adds a new hypothesis with the same name <code>h := h a₁ ... aₙ</code>
and tries to clear the previous one.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.specialize" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticUnhygienic_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L699-L699">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticUnhygienic_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>unhygienic tacs</code> runs <code>tacs</code> with name hygiene disabled.
This means that tactics that would normally create inaccessible names will instead
make regular variables. <strong>Warning</strong>: Tactics may change their variable naming
strategies at any time, so code that depends on autogenerated names is brittle.
Users should try not to use <code>unhygienic</code> if possible.</p><pre><code>example : ∀ x : Nat, x = x := by unhygienic
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>            -- x would normally be intro'd as inaccessible
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a> x  -- refer to x
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.tacticUnhygienic_" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.fail"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L701-L702">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.fail"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">fail</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.fail">fail</a> msg</code> is a tactic that always fails, and produces an error using the given message.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.fail" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.checkpoint"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L704-L715">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">checkpoint</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint">checkpoint</a> tac</code> acts the same as <code>tac</code>, but it caches the input and output of <code>tac</code>,
and if the file is re-elaborated and the input matches, the tactic is not re-run and
its effects are reapplied to the state. This is useful for improving responsiveness
when working on a long tactic proof, by wrapping expensive tactics with <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint">checkpoint</a></code>.</p><p>See the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> tactic, which may be more convenient to use.</p><p>(TODO: do this automatically and transparently so that users don't have to use
this combinator explicitly.)</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.checkpoint" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.save"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L727-L727">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.save"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">save</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> is defined to be the same as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">skip</a></code>, but the elaborator has
special handling for occurrences of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> in tactic scripts and will transform
<code>by tac1; save; tac2</code> to <code>by (checkpoint tac1); tac2</code>, meaning that the effect of <code>tac1</code>
will be cached and replayed. This is useful for improving responsiveness
when working on a long tactic proof, by using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> after expensive tactics.</p><p>(TODO: do this automatically and transparently so that users don't have to use
this combinator explicitly.)</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.save" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sleep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L729-L733">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.sleep"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sleep</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.sleep">sleep</a> ms</code> sleeps for <code>ms</code> milliseconds and does nothing.
It is used for debugging purposes only.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.sleep" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticExists_,,»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L739-L740">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticExists_,,»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>exists e₁, e₂, ...</code> is shorthand for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> ⟨e₁, e₂, ...⟩; try <a href=".././Init/Core.html#trivial">trivial</a></code>.
It is useful for existential goals.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.«tacticExists_,,»" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.congr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L742-L750">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.congr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">congr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Apply congruence (recursively) to goals of the form <code>⊢ f as = f bs</code> and <code>⊢ <a href=".././Init/Prelude.html#HEq">HEq</a> (f as) (f bs)</code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code><a href=".././Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>⊢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href=".././Init/Prelude.html#congr">congr</a></code> produces the goals <code>⊢ x = y</code> and <code>⊢ y = x</code>,
while <code><a href=".././Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>⊢ x + y = y + x</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Tactic.congr" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.simp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L755-L798">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Attr.simp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">simp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Theorems tagged with the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> attribute are by the simplifier
(i.e., the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> tactic, and its variants) to simplify expressions occurring in your goals.
We call theorems tagged with the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> attribute "simp theorems" or "simp lemmas".
Lean maintains a database/index containing all active simp theorems.
Here is an example of a simp theorem.</p><pre><code class="language-lean">@[simp] theorem <a href=".././Init/SimpLemmas.html#ne_eq">ne_eq</a> (a b : α) : (a ≠ b) = <a href=".././Init/Prelude.html#Not">Not</a> (a = b) := <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><p>This simp theorem instructs the simplifier to replace instances of the term
<code>a ≠ b</code> (e.g. <code>x + 0 ≠ y</code>) with <code><a href=".././Init/Prelude.html#Not">Not</a> (a = b)</code> (e.g., <code><a href=".././Init/Prelude.html#Not">Not</a> (x + 0 = y)</code>).
The simplifier applies simp theorems in one direction only:
if <code>A = B</code> is a simp theorem, then <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> replaces <code>A</code>s with <code>B</code>s,
but it doesn't replace <code>B</code>s with <code>A</code>s. Hence a simp theorem should have the
property that its right-hand side is "simpler" than its left-hand side.
In particular, <code>=</code> and <code>↔</code> should not be viewed as symmetric operators in this situation.
The following would be a terrible simp theorem (if it were even allowed):</p><pre><code class="language-lean">@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...
</code></pre><p>Replacing 1 with a * a⁻¹ is not a sensible default direction to travel.
Even worse would be a theorem that causes expressions to grow without bound,
causing simp to loop forever.</p><p>By default the simplifier applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> theorems to an expression <code>e</code>
after its sub-expressions have been simplified.
We say it performs a bottom-up simplification.
You can instruct the simplifier to apply a theorem before its sub-expressions
have been simplified by using the modifier <code>↓</code>. Here is an example</p><pre><code class="language-lean">@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=
</code></pre><p>When multiple simp theorems are applicable, the simplifier uses the one with highest priority.
If there are several with the same priority, it is uses the "most recent one". Example:</p><pre><code class="language-lean">@[simp high] theorem <a href=".././Init/SimpLemmas.html#cond_true">cond_true</a> (a b : α) : <a href=".././Init/Prelude.html#cond">cond</a> true a b = a := <a href=".././Init/Prelude.html#rfl">rfl</a>
@[simp low+1] theorem <a href=".././Init/SimpLemmas.html#or_true">or_true</a> (p : Prop) : (p ∨ True) = <a href=".././Init/Prelude.html#True">True</a> :=
  <a href=".././Init/Core.html#propext">propext</a> <| <a href=".././Init/Core.html#Iff.intro">Iff.intro</a> (fun _ => trivial) (fun _ => <a href=".././Init/Prelude.html#Or.inr">Or.inr</a> trivial)
@[simp 100] theorem <a href=".././Init/SimpLemmas.html#ite_self">ite_self</a> {d : <a href=".././Init/Prelude.html#Decidable">Decidable</a> c} (a : α) : <a href=".././Init/Prelude.html#ite">ite</a> c a a = a := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> d <;> <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Parser.Attr.simp" class="instances-for-list"></ul></details></div></div><div class="decl" id="«term‹_›»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L804-L810">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#«term‹_›»"><span class="name">«term‹_›»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>‹t›</code> resolves to an (arbitrary) hypothesis of type <code>t</code>.
It is useful for referring to hypotheses without accessible names.
<code>t</code> may contain holes that are solved by unification with the expected type;
in particular, <code>‹_›</code> is a shortcut for <code>by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-«term‹_›»" class="instances-for-list"></ul></details></div></div><div class="decl" id="tacticGet_elem_tactic_trivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L813-L821">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#tacticGet_elem_tactic_trivial"><span class="name">tacticGet_elem_tactic_trivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>get_elem_tactic_trivial</code> is an extensible tactic automatically called
by the notation <code>arr[i]</code> to prove any side conditions that arise when
constructing the term (e.g. the index is in bounds of the array).
The default behavior is to just try <code><a href=".././Init/Core.html#trivial">trivial</a></code> (which handles the case
where <code>i < arr.size</code> is in the context) and <code>simp_arith</code>
(for doing linear arithmetic in the index).</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-tacticGet_elem_tactic_trivial" class="instances-for-list"></ul></details></div></div><div class="decl" id="tacticGet_elem_tactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L833-L841">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#tacticGet_elem_tactic"><span class="name">tacticGet_elem_tactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>get_elem_tactic</code> is the tactic automatically called by the notation <code>arr[i]</code>
to prove any side conditions that arise when constructing the term
(e.g. the index is in bounds of the array). It just delegates to
<code>get_elem_tactic_trivial</code> and gives a diagnostic error message otherwise;
users are encouraged to extend <code>get_elem_tactic_trivial</code> instead of this tactic.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-tacticGet_elem_tactic" class="instances-for-list"></ul></details></div></div><div class="decl" id="«term__[_]»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L843-L844">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#«term__[_]»"><span class="name">«term__[_]»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The syntax <code>arr[i]</code> gets the <code>i</code>'th element of the collection <code>arr</code>.
If there are proof side conditions to the application, they will be automatically
inferred by the <code>get_elem_tactic</code> tactic.</p><p>The actual behavior of this class is type-dependent,
but here are some important implementations:</p><ul>
<li><code>arr[i] : α</code> where <code>arr : <a href=".././Init/Prelude.html#Array">Array</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code> or <code>i : <a href=".././Init/Prelude.html#USize">USize</a></code>:
does array indexing with no bounds check and a proof side goal <code>i < arr.size</code>.</li>
<li><code>l[i] : α</code> where <code>l : <a href=".././Init/Prelude.html#List">List</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: index into a list,
with proof side goal <code>i < l.length</code>.</li>
<li><code>stx[i] : Syntax</code> where <code>stx : Syntax</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: get a syntax argument,
no side goal (returns <code>.missing</code> out of range)</li>
</ul><p>There are other variations on this syntax:</p><ul>
<li><code>arr[i]</code>: proves the proof side goal by <code>get_elem_tactic</code></li>
<li><code>arr[i]!</code>: panics if the side goal is false</li>
<li><code>arr[i]?</code>: returns <code>none</code> if the side goal is false</li>
<li><code>arr[i]'h</code>: uses <code>h</code> to prove the side goal</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-«term__[_]»" class="instances-for-list"></ul></details></div></div><div class="decl" id="«term__[_]'_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/a62d2fd4979671b76b8ab13ccbe4fdf410ec0d9d/src/Init/Tactics.lean#L847-L848">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#«term__[_]'_»"><span class="name">«term__[_]'_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The syntax <code>arr[i]</code> gets the <code>i</code>'th element of the collection <code>arr</code>.
If there are proof side conditions to the application, they will be automatically
inferred by the <code>get_elem_tactic</code> tactic.</p><p>The actual behavior of this class is type-dependent,
but here are some important implementations:</p><ul>
<li><code>arr[i] : α</code> where <code>arr : <a href=".././Init/Prelude.html#Array">Array</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code> or <code>i : <a href=".././Init/Prelude.html#USize">USize</a></code>:
does array indexing with no bounds check and a proof side goal <code>i < arr.size</code>.</li>
<li><code>l[i] : α</code> where <code>l : <a href=".././Init/Prelude.html#List">List</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: index into a list,
with proof side goal <code>i < l.length</code>.</li>
<li><code>stx[i] : Syntax</code> where <code>stx : Syntax</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: get a syntax argument,
no side goal (returns <code>.missing</code> out of range)</li>
</ul><p>There are other variations on this syntax:</p><ul>
<li><code>arr[i]</code>: proves the proof side goal by <code>get_elem_tactic</code></li>
<li><code>arr[i]!</code>: panics if the side goal is false</li>
<li><code>arr[i]?</code>: returns <code>none</code> if the side goal is false</li>
<li><code>arr[i]'h</code>: uses <code>h</code> to prove the side goal</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-«term__[_]'_»" class="instances-for-list"></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>